#+TITLE: DotEmacs
#+AUTHOR: Mathieu Marques

A. [[#a-bootstrap][Bootstrap]] |
B. [[#b-theme][Theme]] |
C. [[#c-languages][Languages]] |
D. [[#d-features][Features]]

* A. Bootstrap

1. [[#1-use-better-defaults][Use better defaults]]
2. [[#2-load-customel][Load .custom.el]]
3. [[#3-load-secretel][Load .secret.el]]

** 1. Use better defaults

Some UI elements are rather invasive. No-mouse master race.

#+BEGIN_SRC emacs-lisp
(when window-system
  (blink-cursor-mode 0)                          ; Disable the cursor blinking
  (scroll-bar-mode 0)                            ; Disable the scroll bar
  (tool-bar-mode 0)                              ; Disable the tool bar
  (tooltip-mode 0))                              ; Disable the tooltips
#+END_SRC

Here are what I consider better defaults as per my own experience.

#+BEGIN_SRC emacs-lisp
(setq-default
 ad-redefinition-action 'accept                   ; Silence warnings for redefinition
 confirm-kill-emacs 'yes-or-no-p                  ; Confirm before exiting Emacs
 cursor-in-non-selected-windows t                 ; Hide the cursor in inactive windows
 delete-by-moving-to-trash t                      ; Delete files to trash
 display-time-default-load-average nil            ; Don't display load average
 display-time-format "%H:%M"                      ; Format the time string
 fill-column 85                                   ; Set width for automatic line breaks
 help-window-select t                             ; Focus new help windows when opened
 indent-tabs-mode nil                             ; Stop using tabs to indent
 inhibit-startup-screen t                         ; Disable start-up screen
 initial-scratch-message ""                       ; Empty the initial *scratch* buffer
 mode-require-final-newline 'visit                ; Add a newline at EOF on visit
 mouse-yank-at-point t                            ; Yank at point rather than pointer
 ns-use-srgb-colorspace nil                       ; Don't use sRGB colors
 recenter-positions '(5 bottom)                   ; Set re-centering positions
 scroll-conservatively most-positive-fixnum       ; Always scroll by one line
 select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
 show-trailing-whitespace nil                     ; Display trailing whitespaces
 split-height-threshold nil                       ; Disable vertical window splitting
 split-width-threshold nil                        ; Disable horizontal window splitting
 tab-width 4                                      ; Set width for tabs
 uniquify-buffer-name-style 'forward              ; Uniquify buffer names
 window-combination-resize t)                     ; Resize windows proportionally
(display-time-mode 1)                             ; Enable time in the mode-line
(fringe-mode '(10 . 10))                          ; Show vertical fringes
(fset 'yes-or-no-p 'y-or-n-p)                     ; Replace yes/no prompts with y/n
(global-hl-line-mode 1)                           ; Hightlight current line
(global-subword-mode 1)                           ; Iterate through CamelCase words
(menu-bar-mode 0)                                 ; Disable the menu bar
(mouse-avoidance-mode 'banish)                    ; Avoid collision of mouse with point
(put 'downcase-region 'disabled nil)              ; Enable downcase-region
(put 'upcase-region 'disabled nil)                ; Enable upcase-region
(set-frame-parameter nil 'fullscreen 'maximized)  ; Maximize the frame
#+END_SRC

Garbage-collect on focus-out, Emacs /should/ feel snappier.

#+BEGIN_SRC emacs-lisp
(add-hook 'focus-out-hook 'garbage-collect)
#+END_SRC

I want an easy way to change the appearance of things and be consistent about
it. Those variables are used throughout the whole configuration. You could always
customize these in =~/.emacs.d/.secret.el= file.

#+BEGIN_SRC emacs-lisp
(defvar me/font-family            "Monaco"  "The font to use.")
(defvar me/font-size-default      120       "The font size to use for default text.")
(defvar me/font-size-header-line  140       "The font size to use for headers.")
(defvar me/font-size-mode-line    120       "The font size to use for the mode line.")
#+END_SRC

** 2. Load =.custom.el=

One is able to use the customization interface that is bundled within Emacs. It is
meant to help people who are not familiar with Emacs Lisp in the configuration of
Emacs itself. By default, changes in the customization will be automatically detected
and appended at the end of the configuration file, =init.el=.

Since that in my case, the actual configuration file is a new one, crafted by
=org-mode=, adding code at the end of =init.el= might mess things up. The following
tells Emacs to add extra code in another file that would be then loaded, if existing.

#+BEGIN_SRC emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" user-emacs-directory))
(when (file-exists-p custom-file)
  (load custom-file))
#+END_SRC

** 3. Load =.secret.el=

I load =~/.emacs.d/.secret.el= to keep sensible things out of version control. For
instance, you could set your identity by customizing both =user-full-name= and
=user-mail-address=. This is also where you want your API tokens to live.

#+BEGIN_SRC emacs-lisp
(let ((secret.el (expand-file-name ".secret.el" user-emacs-directory)))
  (when (file-exists-p secret.el)
    (load secret.el)))
#+END_SRC

* B. Theme

1. [[#1-set-a-color-palette][Set a color palette]]
2. [[#2-configure-zenburn][Configure Zenburn]]

** 1. Set a color palette

I like to have an accessible copy of my active theme's color codes. That way, I can
fix other packages' colors while still using the same color codes and keep a sane
consistency everywhere.

I consider this method safe because I am using the all-famous
[[https://github.com/bbatsov/zenburn-emacs][Zenburn Emacs port]] palette. It is
/very/ unlikely that any of its tones will ever change.

#+BEGIN_SRC emacs-lisp
(defconst zenburn/bg+3      "#6F6F6F"  "Zenburn palette: #6F6F6F.")
(defconst zenburn/bg+2      "#5F5F5F"  "Zenburn palette: #5F5F5F.")
(defconst zenburn/bg+1      "#4F4F4F"  "Zenburn palette: #4F4F4F.")
(defconst zenburn/bg+0      "#494949"  "Zenburn palette: #494949.")
(defconst zenburn/bg        "#3F3F3F"  "Zenburn palette: #3F3F3F.")
(defconst zenburn/bg-0      "#383838"  "Zenburn palette: #383838.")
(defconst zenburn/bg-1      "#2B2B2B"  "Zenburn palette: #2B2B2B.")
(defconst zenburn/bg-2      "#000000"  "Zenburn palette: #000000.")
(defconst zenburn/blue+1    "#94BFF3"  "Zenburn palette: #94BFF3.")
(defconst zenburn/blue      "#8CD0D3"  "Zenburn palette: #8CD0D3.")
(defconst zenburn/blue-1    "#7CB8BB"  "Zenburn palette: #7CB8BB.")
(defconst zenburn/blue-2    "#6CA0A3"  "Zenburn palette: #6CA0A3.")
(defconst zenburn/blue-3    "#5C888B"  "Zenburn palette: #5C888B.")
(defconst zenburn/blue-4    "#4C7073"  "Zenburn palette: #4C7073.")
(defconst zenburn/blue-5    "#366060"  "Zenburn palette: #366060.")
(defconst zenburn/cyan      "#93E0E3"  "Zenburn palette: #93E0E3.")
(defconst zenburn/fg+1      "#FFFFEF"  "Zenburn palette: #FFFFEF.")
(defconst zenburn/fg        "#DCDCCC"  "Zenburn palette: #DCDCCC.")
(defconst zenburn/fg-1      "#656555"  "Zenburn palette: #656555.")
(defconst zenburn/green+4   "#BFEBBF"  "Zenburn palette: #BFEBBF.")
(defconst zenburn/green+3   "#AFD8AF"  "Zenburn palette: #AFD8AF.")
(defconst zenburn/green+2   "#9FC59F"  "Zenburn palette: #9FC59F.")
(defconst zenburn/green+1   "#8FB28F"  "Zenburn palette: #8FB28F.")
(defconst zenburn/green     "#7F9F7F"  "Zenburn palette: #7F9F7F.")
(defconst zenburn/green-1   "#5F7F5F"  "Zenburn palette: #5F7F5F.")
(defconst zenburn/magenta   "#DC8CC3"  "Zenburn palette: #DC8CC3.")
(defconst zenburn/orange    "#DFAF8F"  "Zenburn palette: #DFAF8F.")
(defconst zenburn/red+1     "#DCA3A3"  "Zenburn palette: #DCA3A3.")
(defconst zenburn/red       "#CC9393"  "Zenburn palette: #CC9393.")
(defconst zenburn/red-1     "#BC8383"  "Zenburn palette: #BC8383.")
(defconst zenburn/red-2     "#AC7373"  "Zenburn palette: #AC7373.")
(defconst zenburn/red-3     "#9C6363"  "Zenburn palette: #9C6363.")
(defconst zenburn/red-4     "#8C5353"  "Zenburn palette: #8C5353.")
(defconst zenburn/yellow    "#F0DFAF"  "Zenburn palette: #F0DFAF.")
(defconst zenburn/yellow-1  "#E0CF9F"  "Zenburn palette: #E0CF9F.")
(defconst zenburn/yellow-2  "#D0BF8F"  "Zenburn palette: #D0BF8F.")
#+END_SRC

** 2. Configure Zenburn

Load =zenburn-theme= and fix some high-level faces to match my personal preferences.

#+BEGIN_SRC emacs-lisp
(use-package zenburn-theme
  :demand t
  :config
  (load-theme 'zenburn t)
  (set-face-attribute 'default nil :height me/font-size-default)
  (set-face-attribute 'font-lock-comment-delimiter-face nil
                      :foreground zenburn/bg+3 :italic t)
  (set-face-attribute 'font-lock-comment-face nil :italic t)
  (set-face-attribute 'font-lock-doc-face nil :italic t)
  (set-face-attribute 'font-lock-function-name-face nil :foreground zenburn/blue)
  (set-face-attribute 'fringe nil :background zenburn/bg-0 :foreground zenburn/bg+3)
  (set-face-attribute 'header-line nil
                      :box `(:line-width 4 :color ,zenburn/bg-1)
                      :height me/font-size-header-line)
  (set-face-attribute 'help-argument-name nil :foreground zenburn/orange)
  (set-face-attribute 'hl-line nil :background zenburn/bg+1)
  (set-face-attribute 'isearch nil :background zenburn/blue :foreground zenburn/bg)
  (set-face-attribute 'isearch-lazy-highlight-face nil
                      :background zenburn/blue-2 :foreground zenburn/bg)
  (set-face-attribute 'region nil :foreground zenburn/green)
  (set-face-attribute 'vertical-border nil :foreground zenburn/bg-1)
  (when (member me/font-family (font-family-list))
    (set-face-attribute 'default nil :font me/font-family)))
#+END_SRC

* C. Languages

1. [[#1-css][CSS]]
2. [[#2-docker][Docker]]
3. [[#3-html][HTML]]
4. [[#4-javascript][JavaScript]]
5. [[#5-lisp][Lisp]]
6. [[#6-markdown][Markdown]]
7. [[#7-org][Org]]
8. [[#8-python][Python]]
9. [[#9-yaml][YAML]]

#+BEGIN_QUOTE
As pedantic as I like to be, some packages have a =use-package= clause for nothing
but the customization of its lighter.
#+END_QUOTE

- *TODO*: Add a list of all custom shortcuts.
- *TODO*: Replace all old defadvice's.

** 1. CSS

#+BEGIN_SRC emacs-lisp
(use-package css-mode
  :delight css-mode "CSS"
  :config (setq-default css-indent-offset 2))

(use-package scss-mode
  :delight scss-mode "SCSS"
  :mode ("\\.css\\'" "\\.sass\\'" "\\.scss\\'")
  :init
  (add-hook 'scss-mode-hook
            (lambda ()
              (setq-local comment-end "")
              (setq-local comment-start "//")))
  :config (setq-default scss-compile-at-save nil))
#+END_SRC

** 2. Docker

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :delight dockerfile-mode "Dockerfile"
  :mode "Dockerfile\\'")
#+END_SRC

** 3. HTML

HTML mode is defined in =sgml-mode.el=.

#+BEGIN_SRC emacs-lisp
(use-package sgml-mode
  :ensure nil
  :delight html-mode "HTML"
  :config (setq-default sgml-basic-offset 2))
#+END_SRC

** 4. JavaScript

Tern is a code-analysis engine for JavaScript. I use it to check syntax and grammar
in my JavaScript code. With an auto-complete frontend, it can also provide candidates
for variables and properties.

- *FIXME*: Indent level is broken
           (https://github.com/joshwnj/json-mode/issues/32).

#+BEGIN_SRC emacs-lisp
(use-package js
  :delight js-mode "JavaScript"
  :config (setq-default js-indent-level 2))

(use-package json-mode
  :delight json-mode "JSON"
  :mode ("\\.jshintrc\\'" "\\.json\\'")
  :config
  (add-hook 'json-mode-hook (lambda () (setq-local js-indent-level 2))))

(use-package tern
  :config (add-hook 'js-mode-hook 'tern-mode))
#+END_SRC

** 5. Lisp

#+BEGIN_SRC emacs-lisp
(use-package lisp-mode
  :ensure nil
  :delight lisp-mode "Lisp"
  :config
  (delight
   '((emacs-lisp-mode "Emacs Lisp")
     (lisp-interaction-mode "Lisp Interaction"))))
#+END_SRC

** 6. Markdown

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :delight markdown-mode "Markdown"
  :mode
  ("INSTALL\\'"
   "CONTRIBUTORS\\'"
   "LICENSE\\'"
   "README\\'"
   "\\.markdown\\'"
   "\\.md\\'")
  :init (add-hook 'markdown-mode-hook 'turn-on-auto-fill)
  :config
  (unbind-key "M-<down>" markdown-mode-map)
  (unbind-key "M-<up>" markdown-mode-map)
  (setq-default markdown-asymmetric-header t))
#+END_SRC

** 7. Org

This very file is organized with =org-mode=. I am definitely not a power user of Org,
but I'm getting there. :-)

#+BEGIN_QUOTE
Org mode is for keeping notes, maintaining TODO lists, planning projects, and
authoring documents with a fast and effective plain-text system.

[[http://orgmode.org/][Carsten Dominik]]
#+END_QUOTE

- *TODO*: Enable whitespace-mode in edit mode.
          See http://emacs.stackexchange.com/q/29424/2397.

#+BEGIN_SRC emacs-lisp
(use-package org
  :delight org-mode "Org"
  :ensure nil
  :bind (:map org-mode-map ("<M-return>" . org-insert-heading-after-current))
  :init
  (add-hook 'org-mode-hook 'org-sticky-header-mode)
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
  :config
  (setq-default
   org-descriptive-links nil
   org-edit-src-content-indentation 0
   org-src-window-setup 'current-window
   org-support-shift-select 'always
   org-startup-folded nil
   org-startup-truncated nil)
  (unbind-key "<C-return>" org-mode-map)
  (unbind-key "<C-S-down>" org-mode-map)
  (unbind-key "<C-S-up>" org-mode-map))
#+END_SRC

Display the current Org header in the header-line.

#+BEGIN_SRC emacs-lisp
(use-package org-sticky-header
  :config
  (setq-default org-sticky-header-full-path t))
#+END_SRC

** 8. Python

- *TODO*: Check what happens when =ipython= is missing.
- *TODO*: Fix for =ipython= 5.1.0.

#+BEGIN_SRC emacs-lisp
(use-package python
  :delight python-mode "Python"
  :config
  (setq-default
   python-shell-interpreter "ipython"
   python-shell-interpreter-args "--colors=Linux --profile=default"
   python-shell-prompt-output-regexp "Out\\[[0-9]+\\]: "
   python-shell-prompt-regexp "In \\[[0-9]+\\]: "
   python-shell-completion-setup-code
   "from IPython.core.completerlib import module_completion"
   python-shell-completion-module-string-code
   "';'.join(module_completion('''%s'''))\n"
   python-shell-completion-string-code
   "';'.join(get_ipython().Completer.all_completions('''%s'''))\n"))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package pip-requirements
  :delight pip-requirements-mode "PyPA Requirements"
  :config
  (add-hook 'pip-requirements-mode-hook
            (lambda () (setq-local completion-ignore-case t))))
#+END_SRC

** 9. YAML

#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :delight yaml-mode "YAML"
  :mode "\\.yml\\'")
#+END_SRC

* D. Features

1. [[#1-auto-completion][Auto-Completion]]
2. [[#2-comments][Comments]]
3. [[#3-customization-menus][Customization Menus]]
4. [[#4-diff][Diff]]
5. [[#5-dired][Dired]]
6. [[#6-expand][Expand]]
7. [[#7-exwm][EXWM]]
8. [[#8-folding][Folding]]
9. [[#9-helm][Helm]]
10. [[#10-helm-plugins][Helm Plugins]]
11. [[#11-hydra][Hydra]]
12. [[#12-irc][IRC]]
13. [[#13-linters][Linters]]
14. [[#14-mode-line][Mode-Line]]
15. [[#15-navigation][Navigation]]
16. [[#16-os-specific][OS-Specific]]
17. [[#17-parentheses][Parentheses]]
18. [[#18-point-and-region][Point and Region]]
19. [[#19-projectile][Projectile]]
20. [[#20-quality-of-life][Quality of Life]]
21. [[#21-slack][Slack]]
22. [[#22-version-control][Version Control]]
23. [[#23-whitespaces][Whitespaces]]
24. [[#24-web-browsing][Web Browsing]]
25. [[#25-windows][Windows]]

** 1. Auto-Completion

Auto-completion at point. Display a small pop-in containing the candidates.

#+BEGIN_QUOTE
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package company
  :defer 1
  :config
  (global-company-mode)
  (setq-default
   company-idle-delay .2
   company-minimum-prefix-length 1
   company-tooltip-align-annotations t))

(use-package company-dabbrev
  :ensure nil
  :after company
  :config (setq-default company-dabbrev-downcase nil))

(use-package company-tern
  :after company
  :config
  (add-to-list 'company-backends 'company-tern)
  (setq-default
   company-tern-meta-as-single-line t
   company-tern-property-marker " *"))
#+END_SRC

** 2. Comments

#+BEGIN_SRC emacs-lisp
(use-package newcomment
  :ensure nil
  :bind ("<M-return>" . comment-indent-new-line)
  :config
  (setq-default
   comment-auto-fill-only-comments t
   comment-multi-line t))
#+END_SRC

** 3. Customization Menus

This merely changes face attributes. It also /Zenburn/ customization buffers a little
more.

- *TODO*: Open a pull request over
  [[https://github.com/bbatsov/zenburn-emacs][zenburn-emacs]].

#+BEGIN_SRC emacs-lisp
(use-package cus-edit
  :ensure nil
  :config
  (set-face-attribute 'custom-group-tag nil
                      :foreground zenburn/yellow :height me/font-size-header-line)
  (set-face-attribute 'custom-state nil :foreground zenburn/green+4)
  (set-face-attribute 'custom-variable-tag nil :foreground zenburn/blue)
  (when (member me/font-family (font-family-list))
    (set-face-attribute 'custom-group-tag nil :font me/font-family)))
#+END_SRC

** 4. Diff

Ediff is a visual interface to Unix =diff=.

#+BEGIN_SRC emacs-lisp
(use-package ediff-util
  :ensure nil
  :preface
  (defun me/setup-ediff-map ()
    (ediff-setup-keymap)
    (define-key ediff-mode-map (kbd "<down>") #'ediff-next-difference)
    (define-key ediff-mode-map (kbd "<up>") #'ediff-previous-difference))
  :init (add-hook 'ediff-mode-hook #'me/setup-ediff-map))

(use-package ediff-wind
  :ensure nil
  :config
  (setq-default
   ediff-split-window-function #'split-window-horizontally
   ediff-window-setup-function #'ediff-setup-windows-plain))
#+END_SRC

** 5. Dired

Configure Dired buffers. Amongst many other things, Emacs is also a file explorer.

- *TODO*: Use the new syntax for advices.

#+BEGIN_SRC emacs-lisp
(use-package dired
  :ensure nil
  :delight dired-mode "Dired"
  :config
  (defadvice dired-readin (after dired-after-updating-hook first () activate)
    "Sort dired listings with directories first before adding marks."
    (save-excursion
      (let (buffer-read-only)
        (forward-line 2)
        (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
      (set-buffer-modified-p nil)))
  (setq-default
   dired-auto-revert-buffer t
   dired-listing-switches "-alh"
   dired-ls-F-marks-symlinks nil
   dired-recursive-copies 'always))

(use-package dired-x
  :ensure nil
  :preface
  (defun me/dired-revert-after-command (command &optional output error)
    (revert-buffer))
  :config
  (advice-add 'dired-smart-shell-command :after #'me/dired-revert-after-command))
#+END_SRC

** 6. Expand

HippieExpand manages expansions a la [[http://emmet.io/][Emmet]]. So I've gathered
all features that look anywhere close to this behavior for it to handle under the
same bind, that is =<C-return>=. Basically it's an expand DWIM.

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :init
  (add-hook 'css-mode-hook 'emmet-mode)
  (add-hook 'sgml-mode-hook 'emmet-mode)
  :config
  (setq-default emmet-move-cursor-between-quote t)
  (unbind-key "<C-return>" emmet-mode-keymap)
  (unbind-key "C-M-<left>" emmet-mode-keymap)
  (unbind-key "C-M-<right>" emmet-mode-keymap)
  (unbind-key "C-c w" emmet-mode-keymap))

(use-package hippie-exp
  :ensure nil
  :preface
  (defun me/emmet-try-expand-line (args)
    "Try `emmet-expand-line' if `emmet-mode' is active. Else, does nothing."
     (interactive "P")
     (when emmet-mode (emmet-expand-line args)))
  :bind ("<C-return>" . hippie-expand)
  :config
  (setq-default
   hippie-expand-try-functions-list '(yas-hippie-try-expand me/emmet-try-expand-line)
   hippie-expand-verbose nil))

(use-package yasnippet
  :init
  (add-hook 'emacs-lisp-mode-hook 'yas-minor-mode)
  (add-hook 'js-mode-hook 'yas-minor-mode)
  (add-hook 'org-mode-hook 'yas-minor-mode)
  (add-hook 'python-mode-hook 'yas-minor-mode)
  (add-hook 'sgml-mode-hook 'yas-minor-mode)
  :config
  (setq-default yas-snippet-dirs '("~/.emacs.d/snippets"))
  (yas-reload-all)
  (unbind-key "TAB" yas-minor-mode-map)
  (unbind-key "<tab>" yas-minor-mode-map))
#+END_SRC

** 7. EXWM

- *TODO*

#+BEGIN_QUOTE
EXWM (Emacs X Window Manager) is a full-featured tiling X window manager for Emacs
built on top of [[https://github.com/ch11ng/xelb][XELB]]. It features:

- Fully keyboard-driven operations
- Hybrid layout modes (tiling & stacking)
- Dynamic workspace support
- ICCCM/EWMH compliance
- (Optional) RandR (multi-monitor) support
- (Optional) Built-in compositing manager
- (Optional) Built-in system tray
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package exwm :disabled t)
#+END_SRC

** 8. Folding

- *TODO*

#+BEGIN_QUOTE
This is a package to perform text folding like in Vim. It has the following features:

- folding of active regions;
- good visual feedback: it's obvious which part of text is folded;
- persistence by default: when you close file your folds don't disappear;
- persistence scales well, you can work on hundreds of files with lots of folds without
  adverse effects;
- it doesn't break indentation or something;
- folds can be toggled from folded state to unfolded and back very easily;
- quick navigation between existing folds;
- you can use mouse to unfold folds (good for beginners and not only for them);
- for fans of avy package: you can use avy to fold text with minimal number of key
  strokes!

[[https://github.com/mrkkrp/vimish-fold][Mark Karpov]]
#+END_QUOTE

- *FIXME*: Doesn't restore folds.

#+BEGIN_SRC emacs-lisp
(use-package vimish-fold
  :defer 1
  :bind
  (:map vimish-fold-folded-keymap("<tab>" . vimish-fold-unfold)
   :map vimish-fold-unfolded-keymap ("<tab>" . vimish-fold-refold))
  :config
  (setq-default
   vimish-fold-dir (expand-file-name ".vimish-fold/" user-emacs-directory)
   vimish-fold-header-width 79)
  (vimish-fold-global-mode 1))
#+END_SRC

** 9. Helm

Helm is a beast. Although heavily, it replaces =ido-mode= in many ways.

#+BEGIN_QUOTE
=Helm= is an Emacs framework for incremental completions and narrowing selections. It
helps to rapidly complete file names, buffer names, or any other Emacs interactions
requiring selecting an item from a list of possible choices.

Helm is a fork of =anything.el=, which was originally written by Tamas Patrovic and
can be considered to be its successor. =Helm= cleans the legacy code that is leaner,
modular, and unchained from constraints of backward compatibility.

[[https://github.com/emacs-helm/helm][Bozhidar Batsov]]
#+END_QUOTE

- *TODO*: Make helm-list-faces-display.
- *TODO*: Add a flashing effect with Helm actions
          =(progn (require 'pulse) (pulse-momentary-highlight-one-line (point))=.

#+BEGIN_SRC emacs-lisp
(use-package helm
  :defer 1
  :config
  (helm-mode 1)
  (setq-default
   helm-always-two-windows t
   helm-display-header-line nil
   helm-split-window-default-side 'left)
  (set-face-attribute 'helm-match nil :foreground zenburn/green+2 :weight 'normal)
  (set-face-attribute 'helm-prefarg nil :foreground zenburn/red)
  (set-face-attribute 'helm-source-header nil
                      :box nil :background 'unspecified :height me/font-size-header-line))
#+END_SRC

Helm sub-modules can be customized separately. Many basic Emacs commands have their
Helm equivalents.

- *FIXME*: Fix cases where =curl= is not available.

#+BEGIN_SRC emacs-lisp
(use-package helm-buffers
  :ensure nil
  :after helm
  :config
  (setq-default
   helm-buffers-fuzzy-matching t
   helm-buffer-max-length nil)
  (set-face-attribute 'helm-buffer-directory nil
                      :background 'unspecified :foreground zenburn/blue)
  (set-face-attribute 'helm-buffer-size nil :foreground zenburn/bg+3))

(use-package helm-color
  :ensure nil
  :after helm)

(use-package helm-command
  :ensure nil
  :after helm
  :bind ([remap execute-extended-command] . helm-M-x)
  :config
  (setq-default helm-M-x-fuzzy-match t)
  (set-face-attribute 'helm-M-x-key nil :foreground zenburn/orange :underline nil))

(use-package helm-files
  :ensure nil
  :after helm
  :bind (:map helm-find-files-map ("C-s" . helm-ff-run-grep-ag))
  :config
  (set-face-attribute 'helm-ff-dotted-directory nil :background 'unspecified))

(use-package helm-grep
  :ensure nil
  :after helm
  :config (set-face-attribute 'helm-grep-lineno nil :foreground zenburn/yellow-2))

(use-package helm-misc
  :ensure nil
  :after helm
  :bind ([remap switch-to-buffer] . helm-buffers-list))

(use-package helm-mode
  :ensure nil
  :after helm
  :config
  (setq-default
   helm-completion-in-region-fuzzy-match t
   helm-mode-fuzzy-match t))

(use-package helm-net
  :ensure nil
  :after helm
  :config (setq-default helm-net-prefer-curl t))

(use-package helm-regexp
  :ensure nil
  :after helm
  :config (set-face-attribute 'helm-moccur-buffer nil :foreground zenburn/blue))
#+END_SRC

** 10. Helm Plugins

Fourth-party packages for Helm.

- *NOTE*: Does not respect =helm-split-window-default-side=
          (https://github.com/ShingoFukuyama/helm-css-scss/issues/7).
- *TODO*: Fix Zenburn palette
          (https://github.com/bbatsov/zenburn-emacs/issues/220).
- *TODO*: Add helm-swoop
          (https://github.com/ShingoFukuyama/helm-swoop).

#+BEGIN_SRC emacs-lisp
(use-package helm-ag
  :after helm
  :bind
  (:map helm-ag-map
        ("<left>" . backward-char)
        ("<right>" . forward-char))
  :config (setq-default helm-ag-show-status-function nil))

(use-package helm-css-scss
  :after helm
  :config (setq-default helm-css-scss-split-direction 'split-window-horizontally))

(use-package helm-descbinds
  :after helm
  :bind ([remap describe-key] . helm-descbinds)
  :config (setq-default helm-descbinds-window-style 'split-window))

(use-package helm-describe-modes
  :after helm
  :bind ([remap describe-mode] . helm-describe-modes))

(use-package helm-flycheck
  :after helm)

(use-package helm-projectile
  :after helm
  :config (helm-projectile-toggle 1))
#+END_SRC

** 11. Hydra

Hydra allows me to group binds together. It also shows a list of all implemented
commands in the eho area.

#+BEGIN_QUOTE
Once you summon the Hydra through the prefixed binding (the body + any one head), all
heads can be called in succession with only a short extension.

The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head,
arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his
original purpose, calling his proper command. This makes the Hydra very seamless,
it's like a minor mode that disables itself auto-magically.

[[https://github.com/abo-abo/hydra][Oleh Krehel]]
#+END_QUOTE

- *FIXME*: Allow =TAB= for console users.

#+BEGIN_SRC emacs-lisp
(use-package hydra
  :bind
  ;; ("C-c TAB" . hydra-fold/body)
  ("C-c <tab>" . hydra-fold/body)
  ("C-c d" . hydra-dates/body)
  ("C-c e" . hydra-eyebrowse/body)
  ("C-c f" . hydra-flycheck/body)
  ("C-c g" . hydra-magit/body)
  ("C-c h" . hydra-helm/body)
  ("C-c o" . hydra-org/body)
  ("C-c p" . hydra-projectile/body)
  ("C-c w" . hydra-window/body)
  :config (setq-default hydra-default-hint nil))
#+END_SRC

Group date-related commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-dates (:color blue)
  "
^
^Dates^             ^Insert^            ^Insert with time^
^─────^─────────────^──────^────────────^────────────────^──
[_q_] quit          [_d_] short         [_D_] short
^^                  [_i_] iso           [_I_] iso
^^                  [_l_] long
^^                  ^^                  ^^
"
  ("q" nil)
  ("d" me/date-short)
  ("D" me/date-short-with-time)
  ("i" me/date-iso)
  ("I" me/date-iso-with-time)
  ("l" me/date-long))
#+END_SRC

Group Eyebrowse commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-eyebrowse (:color blue)
  "
^
^Eyebrowse^         ^Do^                ^Switch^
^─────────^─────────^──^────────────────^──────^────────────
[_q_] quit          [_c_] create        [_>_] next
^^                  [_k_] kill          [_>_] previous
^^                  [_r_] rename        [_e_] last
^^                  ^^                  [_s_] switch
^^                  ^^                  ^^
"
  ("q" nil)
  (">" eyebrowse-next-window-config :color red)
  ("<" eyebrowse-prev-window-config :color red)
  ("c" eyebrowse-create-window-config)
  ("e" eyebrowse-last-window-config)
  ("k" eyebrowse-close-window-config :color red)
  ("r" eyebrowse-rename-window-config)
  ("s" eyebrowse-switch-to-window-config))
#+END_SRC

Group Flycheck commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-flycheck (:color blue)
  "
^
^Flycheck^          ^Errors^            ^Checker^
^────────^──────────^──────^────────────^───────^───────────
[_q_] quit          [_c_] check         [_s_] select
[_v_] verify setup  [_n_] next          [_d_] disable
[_m_] manual        [_p_] previous      [_?_] describe
^^                  ^^                  ^^
"
  ("q" nil)
  ("c" flycheck-buffer)
  ("d" flycheck-disable-checker)
  ("m" flycheck-manual)
  ("n" flycheck-next-error :color red)
  ("p" flycheck-previous-error :color red)
  ("s" flycheck-select-checker)
  ("v" flycheck-verify-setup)
  ("?" flycheck-describe-checker))
#+END_SRC

Group folding commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-fold (:color pink)
  "
^
^Fold^              ^Do^                ^Jump^              ^Toggle^
^────^──────────────^──^────────────────^────^──────────────^──────^────────────
[_q_] quit          [_f_] fold          [_n_] next          [_<tab>_] current
^^                  [_k_] kill          [_p_] previous      [_S-<tab>_] all
^^                  [_K_] kill all      ^^                  ^^
^^                  ^^                  ^^                  ^^
"
  ("q" nil)
  ("<tab>" vimish-fold-toggle)
  ("S-<tab>" vimish-fold-toggle-all)
  ("f" vimish-fold)
  ("k" vimish-fold-delete)
  ("K" vimish-fold-delete-all)
  ("n" vimish-fold-next-fold)
  ("p" vimish-fold-previous-fold))
#+END_SRC

Group Helm commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-helm (:color blue)
  "
^
^Helm^              ^Browse^            ^Do^
^────^──────────────^──────^────────────^──^────────────────
[_q_] quit          [_c_] colors        [_f_] flycheck
[_r_] resume helm   [_g_] google        [_s_] css-scss
^^                  [_h_] headings      [_t_] fontawesome
^^                  [_i_] imenu         ^^
^^                  ^^                  ^^
"
  ("q" nil)
  ("c" helm-colors)
  ("f" helm-flycheck)
  ("g" helm-google-suggest)
  ("h" helm-org-in-buffer-headings)
  ("i" helm-imenu)
  ("r" helm-resume)
  ("s" helm-css-scss)
  ("t" helm-fontawesome))
#+END_SRC

Group Magit commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-magit (:color blue)
  "
^
^Magit^             ^Do^
^─────^─────────────^──^────────────────
[_q_] quit          [_b_] blame
^^                  [_s_] status
^^                  ^^
"
  ("q" nil)
  ("b" magit-blame)
  ("s" magit-status))
#+END_SRC

Group Org commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-org (:color pink)
  "
^
^Org^               ^Links^             ^Outline^
^───^───────────────^─────^─────────────^───────^───────────
[_q_] quit          [_i_] insert        [_a_] show all
^^                  [_n_] next          [_b_] backward
^^                  [_o_] open          [_f_] forward
^^                  [_p_] previous      [_v_] overview
^^                  [_s_] store         ^^
^^                  ^^                  ^^
"
  ("q" nil)
  ("a" show-all)
  ("b" org-backward-element)
  ("f" org-forward-element)
  ("i" org-insert-link)
  ("n" org-next-link)
  ("o" org-open-at-point)
  ("p" org-previous-link)
  ("s" org-store-link)
  ("v" org-overview))
#+END_SRC

Group Projectile commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-projectile (:color blue)
  "
^
^Projectile^        ^Buffers^           ^Find^              ^Search^
^──────────^────────^───────^───────────^────^──────────────^──────^────────────
[_q_] quit          [_b_] list all      [_d_] directory     [_r_] replace
[_i_] reset cache   [_k_] kill all      [_D_] root          [_s_] ag
^^                  [_S_] save all      [_f_] file          ^^
^^                  ^^                  [_p_] project       ^^
^^                  ^^                  ^^                  ^^
"
  ("q" nil)
  ("b" helm-projectile-switch-to-buffer)
  ("d" helm-projectile-find-dir)
  ("D" projectile-dired)
  ("f" helm-projectile-find-file)
  ("i" projectile-invalidate-cache :color red)
  ("k" projectile-kill-buffers)
  ("p" helm-projectile-switch-project)
  ("r" projectile-replace)
  ("s" helm-projectile-ag)
  ("S" projectile-save-project-buffers :color red))
#+END_SRC

Group window-related commands.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-window (:color blue)
  "
^
^Window^            ^Golden-Ratio^      ^Zoom^
^──────^────────────^────────────^──────^────^──────────────
[_q_] quit          [_2_] bi-split      [_-_] zoom out
^^                  [_3_] tri-split     [_+_] zoom in
^^                  ^^                  [_=_] reset
^^                  ^^                  ^^
"
  ("q" nil)
  ("-" text-scale-decrease :color red)
  ("+" text-scale-increase :color red)
  ("=" (text-scale-increase 0) :color red)
  ("2" (golden-ratio-adjust me/golden-ratio-adjust-factor-bi-split) :color red)
  ("3" (golden-ratio-adjust me/golden-ratio-adjust-factor-tri-split) :color red))
#+END_SRC

** 12. IRC

- *TODO*: Use =.secret.el=.

#+BEGIN_SRC emacs-lisp
(use-package erc
  :preface
  (defun me/erc-bol-with-region () (interactive "^") (erc-bol))
  (defun me/update-erc-fill-column ()
    "Update `erc-fill-column' when window configuration changes."
    (save-excursion
      (walk-windows
       (lambda (w)
         (let ((buffer (window-buffer w)))
           (set-buffer buffer)
           (when (eq major-mode 'erc-mode)
             (setq erc-fill-column (- (window-width w) 1))))))))
  :bind
  (:map erc-mode-map
        ([remap erc-bol] . me/erc-bol-with-region)
        ("C-<down>" . erc-next-command)
        ("C-<up>" . erc-previous-command))
  :config
  (make-variable-buffer-local 'erc-fill-column)
  (add-hook 'window-configuration-change-hook 'me/update-erc-fill-column)
  (erc-scrolltobottom-mode)

  (setq-default
   erc-fill-function 'erc-fill-static
   erc-fill-static-center 16
   erc-header-line-format nil
   erc-hide-list '("JOIN" "PART" "QUIT")
   erc-lurker-hide-list '("JOIN" "PART" "QUIT")
   erc-nick "angrybacon"
   erc-input-line-position -1
   erc-insert-timestamp-function 'erc-insert-timestamp-left
   erc-timestamp-format "[%H:%M:%S] "
   erc-timestamp-only-if-changed-flag nil))
#+END_SRC

** 13. Linters

Flycheck lints warnings and errors directly within buffers. It can check a lot of
different syntaxes, as long as you make sure that Emacs has access to the binaries
(see [[./README.md][README.md]]).

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :init
  (add-hook 'emacs-lisp-mode-hook 'flycheck-mode)
  (add-hook 'js-mode-hook 'flycheck-mode)
  (add-hook 'python-mode-hook 'flycheck-mode)
  (add-hook 'scss-mode-hook 'flycheck-mode)
  :config
  (setq-default
   flycheck-check-syntax-automatically '(save mode-enabled)
   flycheck-disabled-checkers '(emacs-lisp-checkdoc)
   flycheck-display-errors-delay .3)
  (set-face-attribute 'flycheck-error nil :underline zenburn/red-1)
  (set-face-attribute 'flycheck-info nil :underline zenburn/blue+1)
  (set-face-attribute 'flycheck-warning nil :underline zenburn/orange)
  (set-face-attribute 'flycheck-fringe-error nil :foreground zenburn/red-1)
  (set-face-attribute 'flycheck-fringe-info nil :foreground zenburn/blue+1)
  (set-face-attribute 'flycheck-fringe-warning nil :foreground zenburn/orange))
#+END_SRC

** 14. Mode-Line

*** Screenshots

- *TODO*: Update screenshots and documentation.

Here is how it looks (slightly deprecated):

/In an active window/

[[./screenshots/emacs.mode-line.active.png]]

/In an inactive window/

[[./screenshots/emacs.mode-line.inactive.png]]

/When inside of a Helm session/

[[./screenshots/emacs.mode-line.helm.png]]

/When using isearch/

[[./screenshots/emacs.mode-line.search.png]]

/With an active region/

[[./screenshots/emacs.mode-line.region.png]]

- Green means buffer is clean.
- Red means buffer is modified.
- Blue means buffer is read-only.
- Colored bullets represent =flycheck= critical, warning and informational errors.
- The segment next to the clock indicate the current perspective from =eyebrowse=.

*** Delight

Delight allows you to change modes --- both major and minor --- lighters. They are
the descriptive strings than you see appear within the =mode-line=.

To make it work with =spaceline= (which uses =powerline= internally), I need to allow
it to use the newly changed strings.

- *TODO*: Use the new syntax for advices.

#+BEGIN_SRC emacs-lisp
(use-package delight
  :config
  (defadvice powerline-major-mode (around delight-powerline-major-mode activate)
    (let ((inhibit-mode-name-delight nil)) ad-do-it))
  (defadvice powerline-minor-modes (around delight-powerline-minor-modes activate)
    (let ((inhibit-mode-name-delight nil)) ad-do-it)))
#+END_SRC

*** Spaceline

Spaceline, is a mode-line configuration framework. Like what =powerline= does but at
a shallower level. It's still very customizable nonetheless.

#+BEGIN_QUOTE
This is the package that provides [[http://spacemacs.org/][Spacemacs]] with its
famous mode-line theme. It has been extracted as an independent package for general
fun and profit.

[[https://github.com/TheBB/spaceline][Eivind Fonn]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package spaceline :demand t)
(use-package spaceline-config
  :ensure nil
  :after spaceline

  :config

  ;; Configure the mode-line
  (setq-default
   mode-line-format '("%e" (:eval (spaceline-ml-main)))
   powerline-default-separator 'wave
   spaceline-display-default-perspective t
   powerline-height 20
   spaceline-highlight-face-func 'spaceline-highlight-face-modified
   spaceline-flycheck-bullet "• %s"
   spaceline-separator-dir-left '(left . left)
   spaceline-separator-dir-right '(right . right))
  (spaceline-helm-mode)

  ;; Build a segment for the version control branch
  (spaceline-define-segment me/version-control
    (when vc-mode
      (substring vc-mode (+ 2 (length (symbol-name (vc-backend buffer-file-name)))))))

  ;; Build a segment for helm-follow-mode
  (spaceline-define-segment me/helm-follow
    (when (and (bound-and-true-p helm-alive-p)
               spaceline--helm-current-source
               (eq 1 (cdr (assq 'follow spaceline--helm-current-source))))
      (propertize "" 'face 'success)))

  ;; Build a segment for the active region
  (spaceline-define-segment me/selection-info
    (when mark-active
      (let* ((lines (count-lines (region-beginning) (min (1+ (region-end)) (point-max))))
             (chars (- (1+ (region-end)) (region-beginning)))
             (cols (1+ (abs (- (spaceline--column-number-at-pos (region-end))
                               (spaceline--column-number-at-pos (region-beginning))))))
             (rect (bound-and-true-p rectangle-mark-mode))
             (multi-line (> lines 1)))
        (cond
         (rect (format "%d × %d" (1- cols) lines))
         (multi-line (format "%d lines" (if (eq (current-column) 0) (1- lines) lines)))
         (t (format "%d chars" (1- chars)))))))

  ;; Build the mode-lines
  (spaceline-install
   `((major-mode :face highlight-face)
     ((remote-host buffer-id line) :separator ":")
     (anzu))
   `((me/selection-info)
     ((flycheck-error flycheck-warning flycheck-info) :when active)
     ((projectile-root me/version-control) :separator "  ")
     (workspace-number)
     (global :face highlight-face)))
  (spaceline-install
   'helm
   '((helm-buffer-id :face spaceline-read-only)
     (helm-number)
     (me/helm-follow :fallback "")
     helm-prefix-argument)
   '((global :face spaceline-read-only)))

  ;; Customize the mode-line
  (set-face-attribute 'mode-line nil
                      :box `(:line-width 1 :color ,zenburn/bg-2)
                      :foreground zenburn/bg+3
                      :height me/font-size-mode-line)
  (set-face-attribute 'mode-line-inactive nil
                      :box `(:line-width 1 :color ,zenburn/bg-2)
                      :foreground zenburn/bg+3
                      :height me/font-size-mode-line)
  (set-face-attribute 'powerline-active2 nil :background zenburn/bg+2)
  (set-face-attribute 'powerline-inactive2 nil :background zenburn/bg+2)
  (set-face-attribute 'spaceline-flycheck-error nil :foreground zenburn/red)
  (set-face-attribute 'spaceline-flycheck-info nil :foreground zenburn/blue)
  (set-face-attribute 'spaceline-flycheck-warning nil :foreground zenburn/orange)
  (set-face-attribute 'spaceline-modified nil
                      :background zenburn/red :foreground zenburn/red-4)
  (set-face-attribute 'spaceline-read-only nil
                      :background zenburn/blue+1 :foreground zenburn/blue-5)
  (set-face-attribute 'spaceline-unmodified nil
                      :background zenburn/green :foreground zenburn/green+4))
#+END_SRC

** 15. Navigation

I disagree with Emacs' definition of paragraphs so I redefined the way it should jump
from one block to another.

- *FIXME*: Ignore invisible text.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<C-down>") 'me/goto-next-block)
(global-set-key (kbd "<C-up>") 'me/goto-previous-block)

(defun me/goto-next-block ()
  "Jump to next paragraph."
  (interactive "^")
  (skip-chars-forward "\n")
  (unless (search-forward-regexp "\n[[:blank:]]*\n" nil t)
    (goto-char (point-max)))
  (skip-chars-forward "\n"))

(defun me/goto-previous-block ()
  "Jump to previous paragraph."
  (interactive "^")
  (skip-chars-backward "\n")
  (unless (search-backward-regexp "\n[[:blank:]]*\n" nil t)
    (goto-char (point-min)))
  (skip-chars-forward "\n"))
#+END_SRC

Smarter =C-a=.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-a") 'me/beginning-of-line-dwim)

(defun me/beginning-of-line-dwim ()
  "Move point to first non-whitespace character, or beginning of line."
  (interactive "^")
  (let ((origin (point)))
    (beginning-of-line)
    (and (= origin (point))
         (back-to-indentation))))
#+END_SRC

Better search and replace features. Even though I prefer to use =multiple-cursors= to
replace text in different places at once, =anzu= has a nice feedback on regexp
matches.

#+BEGIN_QUOTE
=anzu.el= is an Emacs port of [[https://github.com/osyo-manga/vim-anzu][anzu.vim]].
=anzu.el= provides a minor mode which displays /current match/ and /total matches/
information in the mode-line in various search modes.

[[https://github.com/syohex/emacs-anzu][Syohei Yoshida]]
#+END_QUOTE

/Regular replace/

[[./screencasts/emacs.anzu-replace.gif]]

/Regexp replace/

[[./screencasts/emacs.anzu-replace-regexp.gif]]

- *TODO*: Fix https://github.com/TheBB/spaceline/blob/master/README.org#anzu.

#+BEGIN_SRC emacs-lisp
(use-package anzu
  :defer 1
  :bind ([remap query-replace] . anzu-query-replace-regexp)
  :config
  (global-anzu-mode 1)
  (setq-default
   anzu-cons-mode-line-p nil
   anzu-replace-to-string-separator "  ")
  (set-face-attribute 'anzu-match-3 nil :background zenburn/red)
  (set-face-attribute 'anzu-replace-to nil :foreground zenburn/bg))
#+END_SRC

#+BEGIN_QUOTE
=avy= is a GNU Emacs package for jumping to visible text using a char-based decision
tree. See also [[https://github.com/winterTTr/ace-jump-mode][ace-jump-mode]] and
[[https://github.com/Lokaltog/vim-easymotion][vim-easymotion]] - =avy= uses the same
idea.

[[https://github.com/abo-abo/avy][Oleh Krehel]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package avy
  :bind
  ([remap goto-line] . avy-goto-line)
  ([remap isearch-backward] . avy-goto-char-timer)
  :config (setq-default avy-background t))
#+END_SRC

Isearch stands for /incremental search/. This means that search results are
highlighted while you are typing your query, incrementally. Since he who can do more
can do less, I've replaced default bindings with the regexp-equivalent commands.

- *NOTE*: Still debating whether I prefer =avy= or =isearch= for =C-s=.
- *TODO*: Allow mac-wheel-scroll too.

#+BEGIN_SRC emacs-lisp
(setq-default isearch-allow-scroll t)
(global-set-key [remap isearch-forward] 'isearch-forward-regexp)
#+END_SRC

Configure the mouse wheel events.

#+BEGIN_SRC emacs-lisp
(use-package mwheel
  :ensure nil
  :config (setq-default mouse-wheel-scroll-amount '(1 ((shift) . 5) ((control)))))
#+END_SRC

Bind commands to move around windows.

#+BEGIN_SRC emacs-lisp
(use-package windmove
  :ensure nil
  :bind
  (("C-M-<left>". windmove-left)
   ("C-M-<right>". windmove-right)
   ("C-M-<up>". windmove-up)
   ("C-M-<down>". windmove-down)))
#+END_SRC

** 16. OS-Specific

*** OS X

Augment Emacs experience for OS X users.

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (setq-default
   exec-path (append exec-path '("/usr/local/bin"))  ; Add path to Homebrew binaries
   ns-command-modifier 'meta                         ; Map the Meta key to the `cmd' key
   ns-option-modifier nil))                          ; Disable the `alt' key
#+END_SRC

Initialize environment variables.

#+BEGIN_QUOTE
Ever find that a command works in your shell, but not in Emacs?

This happens a lot on OS X, where an Emacs instance started from the GUI inherits a
default set of environment variables.

This library works solves this problem by copying important environment variables
from the user's shell: it works by asking your shell to print out the variables of
interest, then copying them into the Emacs environment.

[[https://github.com/purcell/exec-path-from-shell][Steve Purcell]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :demand t
  :config
  (when (memq window-system '(mac ns))
    (exec-path-from-shell-initialize)))
#+END_SRC

*** Windows

Fix FontAwesome glyphs.

#+BEGIN_SRC emacs-lisp
(when (eq system-type 'windows-nt)
  (set-fontset-font "fontset-default" '(#xf000 . #xf23a) "FontAwesome"))
#+END_SRC

** 17. Parentheses

Highlight parenthese-like delimiters in a rainbow fashion. It ease the reading when
dealing with mismatched parentheses.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :init
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
  (add-hook 'scss-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

I am still looking for the perfect parenthesis management setup as of today... No
package seem to please my person.

- *TODO*: Find a better parenthese management package.

#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :defer 1
  :bind
  (("M-<backspace>" . sp-unwrap-sexp)
   ("M-<left>" . sp-forward-barf-sexp)
   ("M-<right>" . sp-forward-slurp-sexp)
   ("M-S-<left>" . sp-backward-slurp-sexp)
   ("M-S-<right>" . sp-backward-barf-sexp))
  :config
  (require 'smartparens-config)
  (smartparens-global-mode 1)
  (sp-pair "{{" "}}")
  (sp-pair "[[" "]]"))
#+END_SRC

** 18. Point and Region

Increase region by semantic units. It tries to be smart about it and adapt to the
structure of the current major mode.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :bind ("C-=" . er/expand-region)
  :init (pending-delete-mode t))
#+END_SRC

Enable multiple cursors at once. Some witchcraft at work here.

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors
  :defer 1
  :bind
  (("C-S-<mouse-1>" . mc/add-cursor-on-click)
   ("C-S-c C-S-a" . mc/vertical-align-with-space)
   ("C-S-c C-S-c" . mc/edit-lines)
   ("C-S-c C-S-l" . mc/insert-letters)
   ("C-S-c C-S-n" . mc/insert-numbers)
   ("C-'" . mc-hide-unmatched-lines-mode))
  :init
  (setq-default
   mc/list-file (expand-file-name ".multiple-cursors.el" user-emacs-directory))
  :config
  (setq-default
   mc/edit-lines-empty-lines 'ignore
   mc/insert-numbers-default 1))
#+END_SRC

Enable new custom binds when region is active. I've also added a few helpers to use
with =selected=.

- *TODO*: Make a hydra.

#+BEGIN_SRC emacs-lisp
(use-package selected
  :defer 1
  :bind
  (:map selected-keymap
        ("C-c C-c" . me/eval-region-and-kill-mark)
        ("<M-left>" . me/indent-rigidly-left-and-keep-mark)
        ("<M-right>" . me/indent-rigidly-right-and-keep-mark)
        ("<M-S-left>" . me/indent-rigidly-left-tab-and-keep-mark)
        ("<M-S-right>" . me/indent-rigidly-right-tab-and-keep-mark)
        ("<" . mc/mark-previous-like-this)
        (">" . mc/mark-next-like-this)
        ("C-b b" . me/browse-url-and-kill-mark)
        ("C-c c" . capitalize-region)
        ("C-c l" . downcase-region)
        ("C-c u" . upcase-region)
        ("C-f f" . fill-region)
        ("C-g" . selected-off)
        ("C-s r" . reverse-region)
        ("C-s s" . sort-lines)
        ("C-s w" . me/sort-words))
  :config (selected-global-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun me/eval-region-and-kill-mark (beg end)
  "Execute the region as Lisp code.
Call `eval-region' and kill mark. Move back to the beginning of the region."
  (interactive "r")
  (eval-region beg end)
  (setq deactivate-mark t)
  (goto-char beg))

(defun me/browse-url-and-kill-mark (url &rest args)
  "Ask a WWW browser to load URL.
Call `browse-url' and kill mark."
  (interactive (browse-url-interactive-arg "URL: "))
  (apply #'browse-url url args)
  (setq deactivate-mark t))

(defun me/indent-rigidly-left-and-keep-mark (beg end)
  "Indent all lines between BEG and END leftward by one space.
Call `indent-rigidly-left' and keep mark."
  (interactive "r")
  (indent-rigidly-left beg end)
  (setq deactivate-mark nil))

(defun me/indent-rigidly-right-and-keep-mark (beg end)
  "Indent all lines between BEG and END rightward by one space.
Call `indent-rigidly-right' and keep mark."
  (interactive "r")
  (indent-rigidly-right beg end)
  (setq deactivate-mark nil))

(defun me/indent-rigidly-left-tab-and-keep-mark (beg end)
  "Indent all lines between BEG and END leftward to a tab stop.
Call `indent-rigidly-left-to-tab-stop' and keep mark."
  (interactive "r")
  (indent-rigidly-left-to-tab-stop beg end)
  (setq deactivate-mark nil))

(defun me/indent-rigidly-right-tab-and-keep-mark (beg end)
  "Indent all lines between BEG and END rightward to a tab stop.
Call `indent-rigidly-right-to-tab-stop' and keep mark."
  (interactive "r")
  (indent-rigidly-right-to-tab-stop beg end)
  (setq deactivate-mark nil))

(defun me/sort-words (reverse beg end)
  "Sort words in region alphabetically, in REVERSE if negative.
Prefixed with negative \\[universal-argument], sorts in reverse.

The variable `sort-fold-case' determines whether alphabetic case
affects the sort order.

See `sort-regexp-fields'."
  (interactive "*P\nr")
  (sort-regexp-fields reverse "\\w+" "\\&" beg end))
#+END_SRC

Work on lines.

- *TODO*: Handle regions.

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<M-S-down>") 'me/duplicate-line-down)
(global-set-key (kbd "<M-S-up>") 'me/duplicate-line-up)
(global-set-key (kbd "<M-down>") 'me/swap-line-down)
(global-set-key (kbd "<M-up>") 'me/swap-line-up)

(defun me/duplicate-line-down ()
  "Duplicate downward the line under point."
  (interactive)
  (kill-whole-line 0)
  (yank)
  (newline)
  (yank)
  (move-beginning-of-line 1))

(defun me/duplicate-line-up ()
  "Duplicate upward the line under point."
  (interactive)
  (kill-whole-line 0)
  (yank)
  (move-beginning-of-line 1)
  (yank)
  (newline)
  (move-beginning-of-line 0))

(defun me/swap-line-down ()
  "Move down the line under point."
  (interactive)
  (forward-line 1)
  (transpose-lines 1)
  (forward-line -1)
  (indent-according-to-mode)
  (delete-trailing-whitespace))

(defun me/swap-line-up ()
  "Move up the line under point."
  (interactive)
  (transpose-lines 1)
  (forward-line -2)
  (indent-according-to-mode)
  (delete-trailing-whitespace))
#+END_SRC

** 19. Projectile

Projectile brings project-level facilities to Emacs such as grep, find and replace.

#+BEGIN_QUOTE
Projectile is a project interaction library for Emacs. Its goal is to provide a nice
set of features operating on a project level without introducing external
dependencies (when feasible). For instance - finding project files has a portable
implementation written in pure Emacs Lisp without the use of GNU find (but for
performance sake an indexing mechanism backed by external commands exists as well).

[[https://github.com/bbatsov/projectile][Bozhidar Batsov]]
#+END_QUOTE

- *TODO*: Use the new syntax for advices.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :defer 1
  :preface
  (defun me/projectile-project-name (orig-fun &rest args)
    "Prefer `me/project-name' over default Projectile project string."
    (or me/project-name (apply orig-fun args)))
  :init
  (setq-default
   projectile-cache-file (expand-file-name ".projectile-cache" user-emacs-directory)
   projectile-keymap-prefix (kbd "C-c C-p")
   projectile-known-projects-file (expand-file-name ".projectile-bookmarks" user-emacs-directory))
  :config
  (projectile-global-mode)
  (setq-default
   projectile-completion-system 'helm
   projectile-enable-caching t
   projectile-mode-line '(:eval (projectile-project-name)))
  (advice-add 'projectile-project-name :around #'me/projectile-project-name))
#+END_SRC

** 20. Quality of Life

Auto-dim other buffers. Pretty self-explanatory.

#+BEGIN_SRC emacs-lisp
(use-package auto-dim-other-buffers
  :demand t
  :config
  (auto-dim-other-buffers-mode 1)
  (set-face-attribute 'auto-dim-other-buffers-face nil :background zenburn/bg-0))
#+END_SRC

Insert the current date.

#+BEGIN_SRC emacs-lisp
(defun me/date-iso ()
  "Insert the current date, short format, eg. 2016-12-09."
  (interactive)
  (insert (format-time-string "%F")))

(defun me/date-iso-with-time ()
  "Insert the current date, short format, eg. 2016-12-09T14:34:54+0100."
  (interactive)
  (insert (format-time-string "%FT%T%z")))

(defun me/date-long ()
  "Insert the current date, short format, eg. December 09, 2016."
  (interactive)
  (insert (format-time-string "%B %d, %Y")))

(defun me/date-short ()
  "Insert the current date, short format, eg. 2016.12.09."
  (interactive)
  (insert (format-time-string "%Y.%m.%d")))

(defun me/date-short-with-time ()
  "Insert the current date, short format, eg. 2016.12.09 14:34"
  (interactive)
  (insert (format-time-string "%Y.%m.%d %H:%M")))
#+END_SRC

Insert [[http://fontawesome.io/][fontawesome]] icons.

#+BEGIN_SRC emacs-lisp
(use-package fontawesome)
#+END_SRC

Originally, =midnight= is used to /run something at midnight/. I use its feature that
kills old buffers.

#+BEGIN_SRC emacs-lisp
(use-package midnight
  :config
  (setq-default clean-buffer-list-delay-general 1)
  (add-to-list 'clean-buffer-list-kill-never-buffer-names "dotemacs.org"))
#+END_SRC

Augment Emacs' package menu.

#+BEGIN_QUOTE
Project for modernizing Emacs' Package Menu. With improved appearance, mode-line
information. Github integration, customizability, asynchronous upgrading, and more.

[[https://github.com/Malabarba/paradox][Artur Malabarba]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package paradox
  :config
  (setq-default
   paradox-column-width-package 27
   paradox-column-width-version 13
   paradox-execute-asynchronously t
   paradox-github-token t
   paradox-hide-wiki-packages t)
  (set-face-attribute 'paradox-homepage-button-face nil :italic nil)
  (remove-hook 'paradox--report-buffer-print 'paradox-after-execute-functions))
#+END_SRC

Colorize colors as text with their value.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode
  :init (add-hook 'prog-mode-hook 'rainbow-mode)
  :config (setq-default rainbow-x-colors-major-mode-list '()))
#+END_SRC

** 21. Slack

Slack integration.

- *TODO*
- *TODO*: Register teams in =.secret.el=.
- *TODO*: Create a pull request over https://github.com/yuya373/emacs-slack.

#+BEGIN_SRC emacs-lisp
(use-package slack
  :disabled t
  :commands (slack-start)
  :config
  (setq-default
   slack-buffer-function 'switch-to-buffer
   slack-prefer-current-team t)
  (slack-register-team
   :name "FiftyFor"
   :default t
   :client-id me/fiftyfor-client-id
   :client-secret me/fiftyfor-client-secret
   :token me/fiftyfor-token
   :subscribed-channels '(dev general))
  (set-face-attribute 'slack-message-output-header nil
                      :foreground zenburn/orange :underline nil)
  (set-face-attribute 'slack-message-output-reaction nil
                      :background zenburn/bg+2 :overline nil)
  (set-face-attribute 'slack-message-output-text nil :height 1))
#+END_SRC

** 22. Version Control

Magit provide Git facilities directly from within Emacs.

#+BEGIN_QUOTE
Magit is an interface to the version control system [[https://git-scm.com/][Git]],
implemented as an [[https://www.gnu.org/software/emacs][Emacs]] package. Magit
aspires to be a complete Git porcelain. While we cannot (yet) claim that Magit wraps
and improves upon each and every Git command, it is complete enough to allow even
experienced Git users to perform almost all of their daily version control tasks
directly from within Emacs. While many fine Git clients exist, only Magit and Git
itself deserve to be called porcelains. [[https://magit.vc/about.html][(more)]]

[[https://github.com/magit/magit][Jonas Bernoulli]]
#+END_QUOTE

- *TODO*: Turn auto-fill-mode on when editing a commit messaged.

#+BEGIN_SRC emacs-lisp
(use-package magit
  :config

  ;; Redefine how Magit display buffers
  (defun me/magit-display-buffer-function (buffer)
    "Render some magit modes in the currently selected buffer."
    (display-buffer
     buffer
     (cond ((and (derived-mode-p 'magit-mode)
                 (eq (with-current-buffer buffer major-mode) 'magit-status-mode))
            nil)
           ((memq (with-current-buffer buffer major-mode)
                  '(magit-process-mode
                    magit-revision-mode
                    magit-diff-mode
                    magit-stash-mode))
            nil)
           (t '(display-buffer-same-window)))))

  ;; Use better defaults
  (setq-default
   magit-display-buffer-function 'me/magit-display-buffer-function
   magit-diff-highlight-hunk-body nil
   magit-popup-display-buffer-action '((display-buffer-same-window))
   magit-refs-show-commit-count (quote all)
   magit-section-show-child-count t
   magit-set-upstream-on-push 'askifnotset)

  ;; Customize lighters
  (delight
   '((magit-diff-mode "Magit Diff")
     (magit-log-mode "Magit Log")
     (magit-popup-mode "Magit Popup")
     (magit-status-mode "Magit Status")))

  ;; Customize faces
  (set-face-attribute 'magit-diff-added nil
                      :background zenburn/bg+0 :foreground zenburn/green+3)
  (set-face-attribute 'magit-diff-context nil :background zenburn/bg+0)
  (set-face-attribute 'magit-diff-file-heading-highlight nil :background 'unspecified)
  (set-face-attribute 'magit-diff-hunk-heading nil :background zenburn/bg+2)
  (set-face-attribute 'magit-diff-hunk-heading-highlight nil :background zenburn/bg+2)
  (set-face-attribute 'magit-diff-removed nil
                      :background zenburn/bg+0 :foreground zenburn/red)
  (set-face-attribute 'magit-popup-heading nil :height me/font-size-header-line)
  (set-face-attribute 'magit-section-heading nil :height me/font-size-header-line)
  (set-face-attribute 'magit-section-highlight nil :background 'unspecified))

(use-package gitattributes-mode :delight gitattributes-mode "Git Attributes")
(use-package gitconfig-mode :delight gitconfig-mode "Git Config")
(use-package gitignore-mode :delight gitignore-mode "Git Ignore")
#+END_SRC

** 23. Whitespaces

Highlight space-like characters, eg. trailing spaces, tabs, empty lines.

#+BEGIN_SRC emacs-lisp
(use-package whitespace
  :demand t
  :config
  (global-whitespace-mode 1)
  (setq-default whitespace-style '(face empty tab trailing))
  (set-face-attribute 'whitespace-empty nil :background zenburn/red-1)
  (set-face-attribute 'whitespace-tab nil :background zenburn/red-1)
  (set-face-attribute 'whitespace-trailing nil :background zenburn/red-1))
#+END_SRC

** 24. Web Browsing

EWW stands for Emacs Web Wowser. Yeah that's right... Emacs is also a Web browser,
text-based that is.

- *TODO*: Check what happens when =eww= is missing.
- *NOTE*: Why can't I use =setq-default= to customize =eww-header-line-format=?

#+BEGIN_SRC emacs-lisp
(use-package eww
  :ensure nil
  :delight eww-mode "Emacs Web Wowser"
  :config (setq eww-header-line-format " %t: %u"))
#+END_SRC

** 25. Windows

Save and restore Emacs status, including buffers, modes, point and windows.

#+BEGIN_SRC emacs-lisp
(use-package desktop
  :demand t
  :config
  (desktop-save-mode 1)
  (add-to-list 'desktop-globals-to-save 'golden-ratio-adjust-factor))
#+END_SRC

Workspaces within Emacs.

#+BEGIN_QUOTE
=eyebrowse= is a global minor mode for Emacs that allows you to manage your window
configurations in a simple manner, just like tiling window managers like i3wm with
their workspaces do. It displays their current state in the modeline by default. The
behaviour is modeled after [[http://ranger.nongnu.org/][ranger]], a file manager
written in Python.

[[https://github.com/wasamasa/eyebrowse][Vasilij Schneidermann]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :demand t
  :bind
  ("<f5>" . eyebrowse-switch-to-window-config-1)
  ("<f6>" . eyebrowse-switch-to-window-config-2)
  ("<f7>" . eyebrowse-switch-to-window-config-3)
  ("<f8>" . eyebrowse-switch-to-window-config-4)
  :config (eyebrowse-mode 1))
#+END_SRC

Adjust the size of every windows and focus the active one. It uses the mathematical
golden ratio somewhere in its formulas.

#+BEGIN_SRC emacs-lisp
(use-package golden-ratio
  :demand t
  :preface
  (defconst me/golden-ratio-adjust-factor-bi-split .805)
  (defconst me/golden-ratio-adjust-factor-tri-split .53)
  (defun me/ediff-comparison-buffer-p ()
    (if (boundp 'ediff-this-buffer-ediff-sessions)
        (progn (balance-windows) ediff-this-buffer-ediff-sessions)))
  :config
  (golden-ratio-mode 1)
  (setq-default golden-ratio-adjust-factor me/golden-ratio-adjust-factor-tri-split)
  (add-to-list 'golden-ratio-exclude-modes "ediff-mode")
  (add-to-list 'golden-ratio-inhibit-functions 'me/ediff-comparison-buffer-p))
#+END_SRC

Allow undo's and redo's with window configurations.

#+BEGIN_QUOTE
Winner mode is a global minor mode that records the changes in the window
configuration (i.e. how the frames are partitioned into windows) so that the changes
can be "undone" using the command =winner-undo=.  By default this one is bound to the
key sequence ctrl-c left.  If you change your mind (while undoing), you can press
ctrl-c right (calling =winner-redo=).

[[https://github.com/emacs-mirror/emacs/blob/master/lisp/winner.el][Ivar Rummelhoff]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package winner
  :ensure nil
  :defer 1
  :config (winner-mode 1))
#+END_SRC

-----

[[#dotemacs][Back to top]]
